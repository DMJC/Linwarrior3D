<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Linwarrior 3D: KDTree&lt; VALUE &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Linwarrior 3D
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classKDTree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">KDTree&lt; VALUE &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Generic KD-Tree for clustering k-dimensional data vectors and finding the nearest stored data vectors (or associated data) for a given sample or for a given sample interval.  
 <a href="classKDTree.html#details">More...</a></p>

<p><code>#include &lt;KDTree.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structKDTree_1_1KDNode.html">KDNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structKDTree_1_1KDNode.html" title="KDNode represents a Single KD-Tree node/leaf or a complete tree/subtree as well.">KDNode</a> represents a Single KD-Tree node/leaf or a complete tree/subtree as well.  <a href="structKDTree_1_1KDNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae35017a524591bd38c6206ccd7512236"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKDTree.html#ae35017a524591bd38c6206ccd7512236">KDTree</a> (unsigned int <a class="el" href="classKDTree.html#a59f89e6783787be5ee5fa0f08d2a9274">kdim</a>, std::list&lt; float * &gt; *dataset, std::list&lt; VALUE &gt; *userset=NULL)</td></tr>
<tr class="memdesc:ae35017a524591bd38c6206ccd7512236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an immutable kd-tree of the given dimensionality (kdim) for the given dataset (and corresponding userset).  <a href="classKDTree.html#ae35017a524591bd38c6206ccd7512236">More...</a><br /></td></tr>
<tr class="separator:ae35017a524591bd38c6206ccd7512236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9751ca30660b9a4003ff4e9b79e4e1b7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKDTree.html#a9751ca30660b9a4003ff4e9b79e4e1b7">~KDTree</a> ()</td></tr>
<tr class="separator:a9751ca30660b9a4003ff4e9b79e4e1b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4b57d21919c42d55af03391f91a1c08"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKDTree.html#af4b57d21919c42d55af03391f91a1c08">size</a> ()</td></tr>
<tr class="memdesc:af4b57d21919c42d55af03391f91a1c08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns amount of (not necessarily unique) stored datavectors.  <a href="classKDTree.html#af4b57d21919c42d55af03391f91a1c08">More...</a><br /></td></tr>
<tr class="separator:af4b57d21919c42d55af03391f91a1c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a95bdaa016bd933ec39f27a83535b4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKDTree.html#a89a95bdaa016bd933ec39f27a83535b4">dim</a> ()</td></tr>
<tr class="memdesc:a89a95bdaa016bd933ec39f27a83535b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of dimensions a stored datavector has/must have.  <a href="classKDTree.html#a89a95bdaa016bd933ec39f27a83535b4">More...</a><br /></td></tr>
<tr class="separator:a89a95bdaa016bd933ec39f27a83535b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f37b042a1e7cd4bd38fc564de81f0da"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKDTree.html#a3f37b042a1e7cd4bd38fc564de81f0da">empty</a> ()</td></tr>
<tr class="memdesc:a3f37b042a1e7cd4bd38fc564de81f0da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the tree contains no data (as of now never).  <a href="classKDTree.html#a3f37b042a1e7cd4bd38fc564de81f0da">More...</a><br /></td></tr>
<tr class="separator:a3f37b042a1e7cd4bd38fc564de81f0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa825ffe1e3289240876ef61482586d78"><td class="memItemLeft" align="right" valign="top">std::list&lt; float * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKDTree.html#aa825ffe1e3289240876ef61482586d78">findDataset</a> (float *datavec)</td></tr>
<tr class="memdesc:aa825ffe1e3289240876ef61482586d78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of similar datavectors to the given datavector note that when the list contains more than one datavector then they are all equal (at least within an epsilon).  <a href="classKDTree.html#aa825ffe1e3289240876ef61482586d78">More...</a><br /></td></tr>
<tr class="separator:aa825ffe1e3289240876ef61482586d78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf66c0aa281220e79ebd2879997728be"><td class="memItemLeft" align="right" valign="top">std::list&lt; float * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKDTree.html#aaf66c0aa281220e79ebd2879997728be">findDatasetInterval</a> (float *min_datavec, float *max_datavec)</td></tr>
<tr class="memdesc:aaf66c0aa281220e79ebd2879997728be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to findDataset(..) but finds datavectors near to the given interval.  <a href="classKDTree.html#aaf66c0aa281220e79ebd2879997728be">More...</a><br /></td></tr>
<tr class="separator:aaf66c0aa281220e79ebd2879997728be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeff245803161ceeb98f5c59566721da"><td class="memItemLeft" align="right" valign="top">std::list&lt; VALUE &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKDTree.html#adeff245803161ceeb98f5c59566721da">findUserset</a> (float *datavec)</td></tr>
<tr class="memdesc:adeff245803161ceeb98f5c59566721da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of associated userdata for similar datavectors to the given datavector note that when the list contains more than one userdata then the found datavectors where all equal (at least within an epsilon).  <a href="classKDTree.html#adeff245803161ceeb98f5c59566721da">More...</a><br /></td></tr>
<tr class="separator:adeff245803161ceeb98f5c59566721da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa176330ce3bd84d490cbeb929ef86891"><td class="memItemLeft" align="right" valign="top">std::list&lt; VALUE &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKDTree.html#aa176330ce3bd84d490cbeb929ef86891">findUsersetInterval</a> (float *min_datavec, float *max_datavec)</td></tr>
<tr class="memdesc:aa176330ce3bd84d490cbeb929ef86891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to findUserset(..) but finds userdata for datavectors near to the given interval.  <a href="classKDTree.html#aa176330ce3bd84d490cbeb929ef86891">More...</a><br /></td></tr>
<tr class="separator:aa176330ce3bd84d490cbeb929ef86891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7982f8c3d5ab1f8b0424031f3e766936"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structKDTree_1_1KDNode.html">KDNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKDTree.html#a7982f8c3d5ab1f8b0424031f3e766936">build</a> (unsigned int <a class="el" href="classKDTree.html#a59f89e6783787be5ee5fa0f08d2a9274">kdim</a>, unsigned int curlvl, unsigned int equaldims, std::list&lt; float * &gt; *dataset, std::list&lt; VALUE &gt; *userset=NULL)</td></tr>
<tr class="memdesc:a7982f8c3d5ab1f8b0424031f3e766936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a KD-Tree of the given dimensionality (kdim) for the given dataset.  <a href="classKDTree.html#a7982f8c3d5ab1f8b0424031f3e766936">More...</a><br /></td></tr>
<tr class="separator:a7982f8c3d5ab1f8b0424031f3e766936"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a59f89e6783787be5ee5fa0f08d2a9274"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKDTree.html#a59f89e6783787be5ee5fa0f08d2a9274">kdim</a></td></tr>
<tr class="separator:a59f89e6783787be5ee5fa0f08d2a9274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff2728dc64d5fe7c96809df43f1f7ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structKDTree_1_1KDNode.html">KDNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKDTree.html#a5ff2728dc64d5fe7c96809df43f1f7ba">root</a></td></tr>
<tr class="separator:a5ff2728dc64d5fe7c96809df43f1f7ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class VALUE&gt;<br />
class KDTree&lt; VALUE &gt;</h3>

<p>Generic KD-Tree for clustering k-dimensional data vectors and finding the nearest stored data vectors (or associated data) for a given sample or for a given sample interval. </p>
<p>The current implementation is for float-array vectors but you may easily replace it with another typed array.</p>
<p>Note: Geo-Hash-Tables have been sufficient and simpler for simple spatial indexing. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae35017a524591bd38c6206ccd7512236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae35017a524591bd38c6206ccd7512236">&#9670;&nbsp;</a></span>KDTree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classKDTree.html">KDTree</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>kdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; float * &gt; *&#160;</td>
          <td class="paramname"><em>dataset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; VALUE &gt; *&#160;</td>
          <td class="paramname"><em>userset</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an immutable kd-tree of the given dimensionality (kdim) for the given dataset (and corresponding userset). </p>
<p>Datavectors must be of dimension kdim. </p>

</div>
</div>
<a id="a9751ca30660b9a4003ff4e9b79e4e1b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9751ca30660b9a4003ff4e9b79e4e1b7">&#9670;&nbsp;</a></span>~KDTree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classKDTree.html">KDTree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7982f8c3d5ab1f8b0424031f3e766936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7982f8c3d5ab1f8b0424031f3e766936">&#9670;&nbsp;</a></span>build()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structKDTree_1_1KDNode.html">KDNode</a>* build </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>kdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>curlvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>equaldims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; float * &gt; *&#160;</td>
          <td class="paramname"><em>dataset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; VALUE &gt; *&#160;</td>
          <td class="paramname"><em>userset</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a KD-Tree of the given dimensionality (kdim) for the given dataset. </p>
<p>Note that the pointers in the dataset are stored in the tree. The algorithm identifies equal dimensions and delivers optimized branches (throw/catch is used to return leafes upwards to the branch where the last difference in data was).</p>
<p>kdim : Dimensionality of datavectors. curlvl : Current level, should be 0 initialy. equaldims : Equal dimensions, should be 0 initialy. dataset: List of datavectors of dimension kdim to cluster. userset: Associated userdata/objects for each datavector (or userset == NULL &lt;=&gt; no userdata at all).</p>
<p>The function is roughly divided into:</p><ul>
<li>Terminal case handling for leaves</li>
<li>Partitioning data into two sets left and right</li>
<li>Recursion for left sub-tree/partition</li>
<li>Recursion for right sub-tree/partition </li>
</ul>

</div>
</div>
<a id="a89a95bdaa016bd933ec39f27a83535b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89a95bdaa016bd933ec39f27a83535b4">&#9670;&nbsp;</a></span>dim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int dim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of dimensions a stored datavector has/must have. </p>

</div>
</div>
<a id="a3f37b042a1e7cd4bd38fc564de81f0da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f37b042a1e7cd4bd38fc564de81f0da">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the tree contains no data (as of now never). </p>

</div>
</div>
<a id="aa825ffe1e3289240876ef61482586d78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa825ffe1e3289240876ef61482586d78">&#9670;&nbsp;</a></span>findDataset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;float*&gt;* findDataset </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>datavec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a list of similar datavectors to the given datavector note that when the list contains more than one datavector then they are all equal (at least within an epsilon). </p>
<p>The returned list is freshly allocated (new'ed). To delete is caller responsibility. </p>

</div>
</div>
<a id="aaf66c0aa281220e79ebd2879997728be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf66c0aa281220e79ebd2879997728be">&#9670;&nbsp;</a></span>findDatasetInterval()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;float*&gt;* findDatasetInterval </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>min_datavec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>max_datavec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Similar to findDataset(..) but finds datavectors near to the given interval. </p>
<p>The returned list is freshly allocated (new'ed). To delete is caller responsibility. </p>

</div>
</div>
<a id="adeff245803161ceeb98f5c59566721da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeff245803161ceeb98f5c59566721da">&#9670;&nbsp;</a></span>findUserset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;VALUE&gt;* findUserset </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>datavec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a list of associated userdata for similar datavectors to the given datavector note that when the list contains more than one userdata then the found datavectors where all equal (at least within an epsilon). </p>
<p>The returned list is freshly allocated (new'ed). To delete is caller responsibility. </p>

</div>
</div>
<a id="aa176330ce3bd84d490cbeb929ef86891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa176330ce3bd84d490cbeb929ef86891">&#9670;&nbsp;</a></span>findUsersetInterval()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;VALUE&gt;* findUsersetInterval </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>min_datavec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>max_datavec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Similar to findUserset(..) but finds userdata for datavectors near to the given interval. </p>
<p>The returned list is freshly allocated (new'ed). To delete is caller responsibility. </p>

</div>
</div>
<a id="af4b57d21919c42d55af03391f91a1c08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4b57d21919c42d55af03391f91a1c08">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns amount of (not necessarily unique) stored datavectors. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a59f89e6783787be5ee5fa0f08d2a9274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59f89e6783787be5ee5fa0f08d2a9274">&#9670;&nbsp;</a></span>kdim</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kdim</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5ff2728dc64d5fe7c96809df43f1f7ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ff2728dc64d5fe7c96809df43f1f7ba">&#9670;&nbsp;</a></span>root</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structKDTree_1_1KDNode.html">KDNode</a>* root</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>de/hackcraft/util/<a class="el" href="KDTree_8h.html">KDTree.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
