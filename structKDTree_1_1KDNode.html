<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Linwarrior 3D: KDTree&lt; VALUE &gt;::KDNode Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Linwarrior 3D
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="classKDTree.html">KDTree</a></li><li class="navelem"><a class="el" href="structKDTree_1_1KDNode.html">KDNode</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structKDTree_1_1KDNode-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">KDTree&lt; VALUE &gt;::KDNode Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="structKDTree_1_1KDNode.html" title="KDNode represents a Single KD-Tree node/leaf or a complete tree/subtree as well.">KDNode</a> represents a Single KD-Tree node/leaf or a complete tree/subtree as well.  
 <a href="structKDTree_1_1KDNode.html#details">More...</a></p>

<p><code>#include &lt;KDTree.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structKDTree_1_1KDNode_1_1no__specific__order.html">no_specific_order</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy ordering/compare function for merge.  <a href="structKDTree_1_1KDNode_1_1no__specific__order.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adc5f655b90414c7064a5e6d9d8263cb1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structKDTree_1_1KDNode.html#adc5f655b90414c7064a5e6d9d8263cb1">KDNode</a> ()</td></tr>
<tr class="separator:adc5f655b90414c7064a5e6d9d8263cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dae8f3ec3d0fdf62f466509e2dc2131"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structKDTree_1_1KDNode.html#a6dae8f3ec3d0fdf62f466509e2dc2131">~KDNode</a> ()</td></tr>
<tr class="separator:a6dae8f3ec3d0fdf62f466509e2dc2131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9605adec430c1985c2eb1f152161fe80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structKDTree_1_1KDNode.html#a9605adec430c1985c2eb1f152161fe80">printLeavesize</a> ()</td></tr>
<tr class="memdesc:a9605adec430c1985c2eb1f152161fe80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print size of KD-Tree leaves.  <a href="structKDTree_1_1KDNode.html#a9605adec430c1985c2eb1f152161fe80">More...</a><br /></td></tr>
<tr class="separator:a9605adec430c1985c2eb1f152161fe80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4b57d21919c42d55af03391f91a1c08"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structKDTree_1_1KDNode.html#af4b57d21919c42d55af03391f91a1c08">size</a> ()</td></tr>
<tr class="memdesc:af4b57d21919c42d55af03391f91a1c08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns amount of (not necessarily unique) stored datavectors.  <a href="structKDTree_1_1KDNode.html#af4b57d21919c42d55af03391f91a1c08">More...</a><br /></td></tr>
<tr class="separator:af4b57d21919c42d55af03391f91a1c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab81999dd3cc153cb0151e99b12d79cbe"><td class="memItemLeft" align="right" valign="top">std::list&lt; float * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structKDTree_1_1KDNode.html#ab81999dd3cc153cb0151e99b12d79cbe">findDatasetInterval</a> (unsigned int <a class="el" href="classKDTree.html#a59f89e6783787be5ee5fa0f08d2a9274">kdim</a>, unsigned int curlvl, float *min_datavec, float *max_datavec)</td></tr>
<tr class="memdesc:ab81999dd3cc153cb0151e99b12d79cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for data vectors near to the given data vector interval (ie.  <a href="structKDTree_1_1KDNode.html#ab81999dd3cc153cb0151e99b12d79cbe">More...</a><br /></td></tr>
<tr class="separator:ab81999dd3cc153cb0151e99b12d79cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae2b7b43e017fe06cf70beb2aa62a04"><td class="memItemLeft" align="right" valign="top">std::list&lt; VALUE &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structKDTree_1_1KDNode.html#aaae2b7b43e017fe06cf70beb2aa62a04">findUsersetInterval</a> (unsigned int <a class="el" href="classKDTree.html#a59f89e6783787be5ee5fa0f08d2a9274">kdim</a>, unsigned int curlvl, float *min_datavec, float *max_datavec)</td></tr>
<tr class="memdesc:aaae2b7b43e017fe06cf70beb2aa62a04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for data vectors near to the given data vector interval (ie.  <a href="structKDTree_1_1KDNode.html#aaae2b7b43e017fe06cf70beb2aa62a04">More...</a><br /></td></tr>
<tr class="separator:aaae2b7b43e017fe06cf70beb2aa62a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a59fa5771d003602c02259cd3203353"><td class="memItemLeft" align="right" valign="top">std::list&lt; float * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structKDTree_1_1KDNode.html#a5a59fa5771d003602c02259cd3203353">findDataset</a> (unsigned int <a class="el" href="classKDTree.html#a59f89e6783787be5ee5fa0f08d2a9274">kdim</a>, unsigned int curlvl, float *datavec)</td></tr>
<tr class="memdesc:a5a59fa5771d003602c02259cd3203353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a set of similar or equal vectors to the given data-vector.  <a href="structKDTree_1_1KDNode.html#a5a59fa5771d003602c02259cd3203353">More...</a><br /></td></tr>
<tr class="separator:a5a59fa5771d003602c02259cd3203353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada084e6f4e4a651ee319fdb7858b67dc"><td class="memItemLeft" align="right" valign="top">std::list&lt; VALUE &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structKDTree_1_1KDNode.html#ada084e6f4e4a651ee319fdb7858b67dc">findUserset</a> (unsigned int <a class="el" href="classKDTree.html#a59f89e6783787be5ee5fa0f08d2a9274">kdim</a>, unsigned int curlvl, float *datavec)</td></tr>
<tr class="memdesc:ada084e6f4e4a651ee319fdb7858b67dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a set of similar or equal vectors to the given data-vector and returns their associated userdata (objects related to those vectors).  <a href="structKDTree_1_1KDNode.html#ada084e6f4e4a651ee319fdb7858b67dc">More...</a><br /></td></tr>
<tr class="separator:ada084e6f4e4a651ee319fdb7858b67dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aba49a249141190ada45164bae6b51161"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structKDTree_1_1KDNode.html#aba49a249141190ada45164bae6b51161">comparevalue</a></td></tr>
<tr class="memdesc:aba49a249141190ada45164bae6b51161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value which splits the data into two halfs along current dimension.  <a href="structKDTree_1_1KDNode.html#aba49a249141190ada45164bae6b51161">More...</a><br /></td></tr>
<tr class="separator:aba49a249141190ada45164bae6b51161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab82f557c494cbc427a6460dce97ca548"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structKDTree_1_1KDNode.html">KDNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structKDTree_1_1KDNode.html#ab82f557c494cbc427a6460dce97ca548">left</a></td></tr>
<tr class="memdesc:ab82f557c494cbc427a6460dce97ca548"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left subtree contains only datavectors v where v[dim] &lt; comparevalue;.  <a href="structKDTree_1_1KDNode.html#ab82f557c494cbc427a6460dce97ca548">More...</a><br /></td></tr>
<tr class="separator:ab82f557c494cbc427a6460dce97ca548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd97a14647a1983d6d43d77df7d53345"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structKDTree_1_1KDNode.html">KDNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structKDTree_1_1KDNode.html#acd97a14647a1983d6d43d77df7d53345">right</a></td></tr>
<tr class="memdesc:acd97a14647a1983d6d43d77df7d53345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right subtree contains only datavectors v where v[dim] &gt;= comparevalue;.  <a href="structKDTree_1_1KDNode.html#acd97a14647a1983d6d43d77df7d53345">More...</a><br /></td></tr>
<tr class="separator:acd97a14647a1983d6d43d77df7d53345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ea761d85f329db02fdd13ab4e4c283"><td class="memItemLeft" align="right" valign="top">std::list&lt; float * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structKDTree_1_1KDNode.html#ad0ea761d85f329db02fdd13ab4e4c283">dataset</a></td></tr>
<tr class="memdesc:ad0ea761d85f329db02fdd13ab4e4c283"><td class="mdescLeft">&#160;</td><td class="mdescRight">If this node is a leaf then dataset stores same datavectors (or one).  <a href="structKDTree_1_1KDNode.html#ad0ea761d85f329db02fdd13ab4e4c283">More...</a><br /></td></tr>
<tr class="separator:ad0ea761d85f329db02fdd13ab4e4c283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5345ba19a37c84bfc978442670758737"><td class="memItemLeft" align="right" valign="top">std::list&lt; VALUE &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structKDTree_1_1KDNode.html#a5345ba19a37c84bfc978442670758737">userset</a></td></tr>
<tr class="memdesc:a5345ba19a37c84bfc978442670758737"><td class="mdescLeft">&#160;</td><td class="mdescRight">If this node is a leaf then userset stores associated userdata.  <a href="structKDTree_1_1KDNode.html#a5345ba19a37c84bfc978442670758737">More...</a><br /></td></tr>
<tr class="separator:a5345ba19a37c84bfc978442670758737"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class VALUE&gt;<br />
struct KDTree&lt; VALUE &gt;::KDNode</h3>

<p><a class="el" href="structKDTree_1_1KDNode.html" title="KDNode represents a Single KD-Tree node/leaf or a complete tree/subtree as well.">KDNode</a> represents a Single KD-Tree node/leaf or a complete tree/subtree as well. </p>
<p>This structure is for use in kdtree class only! </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="adc5f655b90414c7064a5e6d9d8263cb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc5f655b90414c7064a5e6d9d8263cb1">&#9670;&nbsp;</a></span>KDNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structKDTree_1_1KDNode.html">KDNode</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6dae8f3ec3d0fdf62f466509e2dc2131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dae8f3ec3d0fdf62f466509e2dc2131">&#9670;&nbsp;</a></span>~KDNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="structKDTree_1_1KDNode.html">KDNode</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5a59fa5771d003602c02259cd3203353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a59fa5771d003602c02259cd3203353">&#9670;&nbsp;</a></span>findDataset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;float*&gt;* findDataset </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>kdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>curlvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>datavec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds a set of similar or equal vectors to the given data-vector. </p>
<p>If the returned set contains more than one vector then they are equal as for the data but the pointers are different (Data-Vectors do have data+identity). Don't delete returned sets!! Returned sets are part of the kd-tree! </p>

</div>
</div>
<a id="ab81999dd3cc153cb0151e99b12d79cbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab81999dd3cc153cb0151e99b12d79cbe">&#9670;&nbsp;</a></span>findDatasetInterval()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;float*&gt;* findDatasetInterval </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>kdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>curlvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>min_datavec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>max_datavec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search for data vectors near to the given data vector interval (ie. </p>
<p>searching for data vectors matching multidimensional Intervals). Note that the result may contain more data than just the data vectors within the interval (false positives, or fuzziness). You should delete returned sets!! Caller responsibility! </p>

</div>
</div>
<a id="ada084e6f4e4a651ee319fdb7858b67dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada084e6f4e4a651ee319fdb7858b67dc">&#9670;&nbsp;</a></span>findUserset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;VALUE&gt;* findUserset </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>kdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>curlvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>datavec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds a set of similar or equal vectors to the given data-vector and returns their associated userdata (objects related to those vectors). </p>
<p>If the returned set contains more than one vector then they are equal as for the data but the pointers are different (Data-Vectors do have data+identity). Don't delete returned sets!! Returned sets are part of the kd-tree! </p>

</div>
</div>
<a id="aaae2b7b43e017fe06cf70beb2aa62a04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaae2b7b43e017fe06cf70beb2aa62a04">&#9670;&nbsp;</a></span>findUsersetInterval()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;VALUE&gt;* findUsersetInterval </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>kdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>curlvl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>min_datavec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>max_datavec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search for data vectors near to the given data vector interval (ie. </p>
<p>searching for data vectors matching multidimensional Intervals) and returns their associated userdata (objects related to those vectors). Note that the result may contain more data than just within the interval (false positives, or fuzziness). You should delete returned sets!! Caller responsibility! </p>

</div>
</div>
<a id="a9605adec430c1985c2eb1f152161fe80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9605adec430c1985c2eb1f152161fe80">&#9670;&nbsp;</a></span>printLeavesize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void printLeavesize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print size of KD-Tree leaves. </p>

</div>
</div>
<a id="af4b57d21919c42d55af03391f91a1c08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4b57d21919c42d55af03391f91a1c08">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns amount of (not necessarily unique) stored datavectors. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aba49a249141190ada45164bae6b51161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba49a249141190ada45164bae6b51161">&#9670;&nbsp;</a></span>comparevalue</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float comparevalue</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Value which splits the data into two halfs along current dimension. </p>

</div>
</div>
<a id="ad0ea761d85f329db02fdd13ab4e4c283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0ea761d85f329db02fdd13ab4e4c283">&#9670;&nbsp;</a></span>dataset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;float*&gt;* dataset</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If this node is a leaf then dataset stores same datavectors (or one). </p>

</div>
</div>
<a id="ab82f557c494cbc427a6460dce97ca548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab82f557c494cbc427a6460dce97ca548">&#9670;&nbsp;</a></span>left</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structKDTree_1_1KDNode.html">KDNode</a>* left</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Left subtree contains only datavectors v where v[dim] &lt; comparevalue;. </p>

</div>
</div>
<a id="acd97a14647a1983d6d43d77df7d53345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd97a14647a1983d6d43d77df7d53345">&#9670;&nbsp;</a></span>right</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structKDTree_1_1KDNode.html">KDNode</a>* right</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Right subtree contains only datavectors v where v[dim] &gt;= comparevalue;. </p>

</div>
</div>
<a id="a5345ba19a37c84bfc978442670758737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5345ba19a37c84bfc978442670758737">&#9670;&nbsp;</a></span>userset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;VALUE&gt;* userset</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If this node is a leaf then userset stores associated userdata. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>de/hackcraft/util/<a class="el" href="KDTree_8h.html">KDTree.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
